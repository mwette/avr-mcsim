/* i2c_bus.c
 *
 * Copyright (C) 2021-2023 Matthew Wette
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * I2C has two lines, SDA, the data/address line, and SCL, the clock line.
 * Well, and ground of course.  The SDA and SCL lines are held high by an 
 * external +5v supply (can this be 3.3v?) via pull-up.  The terminals, if
 * you will, pull the lines low.  The logic is wired-or.  (MicroChip docs
 * call this wired and.)
 *
 * if any dev pulls SCL or SDA low then it goes low.
 * If any dev initiates a start, then the bus is locked.
 * START: SDA:H->L, then w/ SDA=L SCL:H->L
 * so bus should have a bus_start() command.
 * If SCL=L, then fil
 */
#include <stdint.h>
#include <string.h>			/* memset() */
#include <stdlib.h>			/* abort() */
#include "i2c.h"
#include "util.h"

void i2c_bus_init(i2c_bus_t *bus) {
  memset(bus, 0, sizeof(i2c_bus_t));
}

void i2c_bus_attach(i2c_bus_t *bus, i2c_node_t *node) {
  bus->nodes[node->addr] = node;
}

void i2c_bus_dettach(i2c_bus_t *bus, i2c_node_t *node) {
  bus->nodes[node->addr] = 0;
}

static int i2c_node_bx(i2c_node_t *node, i2c_cmd_t cmd, uint8_t arg) {
  return (node->bx)(node, cmd, arg);
}

/* BUG: This should be on a time scheduler. */
void i2c_cmd_evt(void *arg, tksch_t *sch) {
  i2c_bus_t *bus = arg;
  int err;

  switch (bus->cmd) {
  case I2C_ADDR:
    if (bus->dst) {
      err = i2c_node_bx(bus->dst, bus->cmd, bus->arg);
    } else {
      abort();
#if 0
      for (int i = 0; i < 128; i++) {	/* check order */
	if (bus->nodes[i]) {
	  err = i2c_node_bx(bus->dst, bus->cmd, bus->arg);
	}
      } 
#endif
    }
    break;
  default:
    abort();
    break;
  }
}

/* --- master ---------------------- */

/* @deffn {Function} int i2c_start(*bus, *node, addr, rdflag)
 * @enumeration
 * @item
 * If BUSY, return BUSY.
 * If IDLE, schedule node for end-of-start, set INIT, return INIT.
 * If INIT, return INIT.
 * @end enumeration
 * return 0 if bus acquired and addr sent, -1 if busy
 * @end deffn
 */
int i2c_start(i2c_bus_t *bus, i2c_node_t *node, uint8_t addr, int rdflag) {
  uint32_t at;
  tksch_t *sch;
  
  if (bus->state == I2C_ST_BUSY) {
    return -1;
  } else if (bus->state == I2C_ST_INIT) {
    if (bus->arg > addr) {
      return -1;
    } else {
      /* steal bus 
       * arb lost => current master 
       * bug: not holding clock out for stealer
       * we could schedule for arb-lost message
       */
      bus->master = node;
      abort(); // not done
    }
  } else { /* bus->state == I2C_ST_IDLE */
    bus->state = I2C_ST_INIT;
    bus->master = node;
    /* schedule ack: generated by self */
    sch = node->sch;
    at = sch->tick_last + node->per_tk;
    FIX ME
    // tksch_sync(sch, bus->sch, at);
    tksch_sched(sch, at, -1, i2c_cmd_evt, bus);
  }
}

/* called from node's end-of-start event handler */
int i2c_eos(i2c_bus_t *bus, i2c_node_t *node) {
  if (node == bus->master) {
    return 0;
  } else {
    return -1;
  }
}

/* called from node's end-of-address event handler */
int i2c_eoa(i2c_bus_t *bus, i2c_node_t *node) {
  if (node == bus->master) {
    return 0;
  } else {
    return -1;
  }
}

void i2c_stop(i2c_bus_t *bus, i2c_node_t *node) {
  bus->busy = 0;
  bus->master = 0;
}

/* --- last line --- */
